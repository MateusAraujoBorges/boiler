datatype SysModule = DB | SN | CT | AC
datatype SysAction = Initialise | Register | Terminate | Analysis 

channel query, data, pressure, stop, start, command -- global events
channel internalAction -- placeholder event?
channel sysEvent : SysModule.SysAction

P = query -> data -> P
Q = internalAction -> Q

Database_Initialise =  sysEvent.DB.Initialise -> Database_Register
Database_Register =  sysEvent.DB.Register -> pressure -> (Database_Register [] Database_Analysis [] Database_Terminate)
Database_Terminate =  sysEvent.DB.Terminate -> Database_Initialise
Database_Analysis =  sysEvent.DB.Analysis -> query -> data -> Database_Register
HMSC_Database = internalAction -> Database_Initialise
DatabaseWCoordAct = HMSC_Database\{internalAction}

Control_Initialise = sysEvent.CT.Initialise -> start -> Control_Register
Control_Register = sysEvent.CT.Register -> (Control_Register [] Control_Analysis [] Control_Terminate)
Control_Terminate = sysEvent.CT.Terminate -> stop -> Control_Initialise
Control_Analysis = sysEvent.CT.Analysis -> query -> data -> command -> Control_Register
HMSC_Control = internalAction -> Control_Initialise
ControlWCoordAct = HMSC_Control\{internalAction}

Sensor_Initialise = sysEvent.SN.Initialise -> start -> Sensor_Register
Sensor_Register = sysEvent.SN.Register -> pressure -> (Sensor_Register [] Sensor_Terminate [] Sensor_Analysis)
Sensor_Terminate = sysEvent.SN.Terminate -> stop -> Sensor_Initialise
Sensor_Analysis = sysEvent.SN.Analysis -> Sensor_Register
HMSC_Sensor = internalAction -> Sensor_Initialise
SensorWCoordAct = HMSC_Sensor\{internalAction}

Actuator_Initialise = sysEvent.AC.Initialise -> Actuator_Register
Actuator_Register = sysEvent.AC.Register -> (Actuator_Register [] Actuator_Analysis [] Actuator_Terminate)
Actuator_Terminate = sysEvent.AC.Terminate -> Actuator_Initialise
Actuator_Analysis = sysEvent.AC.Analysis -> command -> Actuator_Register
HMSC_Actuator = internalAction -> Actuator_Analysis
ActuatorWCoordAct = HMSC_Actuator\{internalAction}

internalEvents = {sysEvent.x.y | x <- SysModule, y <- SysAction}
--Database = DatabaseWCoordAct\{{|AllInternalEvents|}}

-- Nos proximos processos, vamos simular a keyword "deterministic" do LTSA ao criar um processo igual ao
-- processo "determinizado", e depois provar que ele eh um refinamento do processo original (sem deterministic)

Database = DatabaseWCoordAct \ internalEvents
DatabaseOnHand = pressure -> DH1
DH1 = pressure -> DH1 [] query -> data -> DatabaseOnHand

Control = ControlWCoordAct \ internalEvents
ControlOnHand = start -> C1
C1 = (stop -> ControlOnHand) [] (query -> data -> command -> C1)

Actuator = ActuatorWCoordAct \ internalEvents
ActuatorOnHand = command -> ActuatorOnHand

Sensor = SensorWCoordAct \ internalEvents
SensorOnHand = start -> pressure -> S1
S1 = (pressure -> S1) [] (stop -> SensorOnHand)

-- o refinamento no sentido contrario nao eh valido (*OnHand -> *), pois existem diferencas entre os
-- os processos na semantica de falha/divergencia.

assert Database [FD= DatabaseOnHand
assert Control [FD= ControlOnHand
assert Actuator [FD= ActuatorOnHand
assert Sensor [FD= SensorOnHand

--- experimento - a função de compressão "diamond" do fdr consegue gerar processos praticamente idênticos aos
--- gerados com a keyword 'deterministic' no LTSA. A bronca eh que o FDR tem boa memoria: caso o processo que
--- serah comprimido tenha nao-deterministico/livelock/deadlock, o FDR ira acusar essas propriedades no processo
--- comprimido, mesmo que a maquina de estados dele nao apresente essas propriedades.

transparent diamond
DatabaseOpt = diamond(Database)
ControlOpt = diamond(Control)
ActuatorOpt = diamond(Actuator)
SensorOpt = diamond(Sensor)

assert Database [FD= DatabaseOpt
assert Control [FD= ControlOpt
assert Actuator [FD= ActuatorOpt
assert Sensor [FD= SensorOpt
assert DatabaseOpt [FD= Database
assert ControlOpt [FD= Control
assert ActuatorOpt [FD= Actuator
assert SensorOpt [FD= Sensor
---

-- compositions

dbAlph = {data,pressure,query}
ctAlph = {command,data,query,start,stop}
snAlph = {pressure,start,stop}
acAlph = {command}

ArchitectureModelP1 = (DatabaseOnHand [dbAlph||ctAlph] ControlOnHand)
ArchitectureModelP2 = (ArchitectureModelP1 [union(dbAlph,ctAlph)||acAlph] ActuatorOnHand)
ArchitectureModel = (ArchitectureModelP2 [union(union(dbAlph,ctAlph),acAlph)||snAlph] SensorOnHand)

dbCoorAlph = union(dbAlph,getModuleAlphabet(DB))
ctCoorAlph = union(ctAlph,getModuleAlphabet(CT))
snCoorAlph = union(snAlph,getModuleAlphabet(SN))
acCoorAlph = union(acAlph,getModuleAlphabet(AC))


--helpers
getModuleAlphabet(b) = {sysEvent.b.x | x <- SysAction}


